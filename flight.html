<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Path - Complete Suite</title>
       <!-- Logging interface -->
    <script src="https://xaxero.com/dlog/tracker.js" data-app-name="FlightPlan"></script>
  
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        /* Core Theme */
        body { 
            background-color: #0f172a; 
            color: #f8fafc; 
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; 
        }
        
        /* Glass Panel */
        .panel { 
            background: rgba(30, 41, 59, 0.95); 
            border: 1px solid #334155; 
            backdrop-filter: blur(12px); 
        }
        
        /* Input Fields */
        .input-field { 
            background: #1e293b; 
            border: 1px solid #475569; 
            color: white; 
            transition: 0.2s; 
        }
        .input-field:focus { 
            border-color: #3b82f6; 
            outline: none; 
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2); 
        }
        
        /* Map & Icons */
        .leaflet-container { background: #020617; }
        .wind-icon { background: transparent; border: none; }
        
        /* Improved Drag Handle */
        .drag-handle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto !important; /* Force pointer events */
        }
        .drag-handle-visual {
            width: 16px;
            height: 16px;
            background: white;
            border: 3px solid #f97316; /* Orange */
            border-radius: 50%; 
            box-shadow: 0 0 0 4px rgba(249, 115, 22, 0.3), 0 0 10px rgba(0,0,0,0.5);
            cursor: grab;
            transition: transform 0.1s ease-out;
        }
        .drag-handle-container:hover .drag-handle-visual { 
            transform: scale(1.5); 
            border-color: #ea580c;
            background: #fff7ed;
        }
        .drag-handle-container:active .drag-handle-visual {
            cursor: grabbing;
            transform: scale(1.2);
        }

        .waypoint-icon {
            background: rgba(15, 23, 42, 0.9);
            border: 2px solid #f97316;
            color: #f97316;
            border-radius: 50%;
            font-weight: bold;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        /* Animations */
        .fade-in { animation: fadeIn 0.4s ease-out; }
        @keyframes fadeIn { 
            from { opacity: 0; transform: translateY(5px); } 
            to { opacity: 1; transform: translateY(0); } 
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }

        /* AI Button Glow */
        .ai-btn-active {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            box-shadow: 0 0 15px rgba(124, 58, 237, 0.5);
            border: 1px solid #a78bfa;
        }

        /* Wait Overlay */
        .wait-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            z-index: 100000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .spinner {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(255, 255, 255, 0.1);
            border-left-color: #a855f7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100001;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        window.addEventListener('load', () => {
            const { useState, useEffect, useRef } = React;

            const TRANSLATIONS = {
                en: {
                    title: "Flight Path",
                    origin: "ORIGIN",
                    dest: "DESTINATION",
                    aircraft: "AIRCRAFT",
                    dep: "DEPARTURE (UTC)",
                    minAlt: "MIN ALT",
                    maxAlt: "MAX ALT",
                    climbPwr: "CLIMB PWR %",
                    cruisePwr: "CRUISE PWR %",
                    fuelUnits: "FUEL UNITS",
                    calc: "CALCULATE FLIGHT",
                    calcing: "CALCULATING...",
                    aiOpt: "AI OPTIMIZE",
                    aiThinking: "AI THINKING...",
                    aiOptimized: "AI OPTIMIZED",
                    reset: "RESET TO DIRECT ROUTE",
                    ete: "ETE",
                    fuel: "FUEL",
                    dist: "DIST",
                    eta: "ETA (UTC)",
                    climbTas: "Climb TAS",
                    cruiseTas: "Cruise TAS",
                    customRoute: "CUSTOM ROUTE ACTIVE",
                    waypoints: "Waypoints",
                    vertProfile: "VERTICAL PROFILE",
                    aiStrategy: "AI Strategy",
                    deviateLeft: "DEVIATE LEFT",
                    deviateRight: "DEVIATE RIGHT",
                    stayCenter: "STAY CENTER",
                    planAlt: "Plan Alt",
                    map: "MAP",
                    sat: "SAT",
                    altitude: "ALTITUDE",
                    helpTitle: "How to Use",
                    helpStart: "Getting Started",
                    helpStartDesc: "Enter 4-letter ICAO codes for your Origin and Destination. Select your aircraft type and click Calculate Flight.",
                    helpEdit: "Elastic Route Editing",
                    helpEditDesc: "Hover over the colored flight path on the map. Drag the orange circle to divert your route. This creates a waypoint and recalculates.",
                    helpVert: "Vertical Profile",
                    helpVertDesc: "The chart shows your flight side-on. Green/Purple line is altitude. Wind barbs show speed/direction.",
                    helpAi: "AI Optimization",
                    helpAiDesc: "(Requires API Key) AI simulates thousands of flights to find the best altitude and route to minimize time and fuel.",
                    gotIt: "Got it",
                    eduWarning: "EDUCATIONAL USE ONLY - USE CERTIFIED TOOLS FOR REAL WORLD PLANNING",
                    apiKey: "API Key (Optional)",
                    getKey: "Get Key",
                    aiError: "AI Service Failed",
                    close: "CLOSE"
                },
                fr: {
                    title: "Plan de Vol",
                    origin: "ORIGINE",
                    dest: "DESTINATION",
                    aircraft: "AVION",
                    dep: "DÉPART (UTC)",
                    minAlt: "ALT MIN",
                    maxAlt: "ALT MAX",
                    climbPwr: "PUISSANCE MONTÉE %",
                    cruisePwr: "PUISSANCE CROISIÈRE %",
                    fuelUnits: "UNITÉS CARBURANT",
                    calc: "CALCULER LE VOL",
                    calcing: "CALCUL EN COURS...",
                    aiOpt: "OPTIMISATION IA",
                    aiThinking: "IA RÉFLÉCHIT...",
                    aiOptimized: "OPTIMISÉ PAR IA",
                    reset: "RÉINITIALISER ROUTE DIRECTE",
                    ete: "ETE",
                    fuel: "CARBURANT",
                    dist: "DIST",
                    eta: "HAE (UTC)",
                    climbTas: "TAS Montée",
                    cruiseTas: "TAS Croisière",
                    customRoute: "ROUTE PERSONNALISÉE",
                    waypoints: "Points de passage",
                    vertProfile: "PROFIL VERTICAL",
                    aiStrategy: "Stratégie IA",
                    deviateLeft: "DÉVIER GAUCHE",
                    deviateRight: "DÉVIER DROITE",
                    stayCenter: "RESTER CENTRE",
                    planAlt: "Alt Prévue",
                    map: "CARTE",
                    sat: "SAT",
                    altitude: "ALTITUDE",
                    helpTitle: "Mode d'emploi",
                    helpStart: "Pour commencer",
                    helpStartDesc: "Entrez les codes ICAO à 4 lettres. Sélectionnez votre avion et cliquez sur Calculer le Vol.",
                    helpEdit: "Édition Élastique",
                    helpEditDesc: "Survolez la ligne de vol sur la carte. Tirez la poignée blanche pour modifier votre route et créer un point de passage.",
                    helpVert: "Profil Vertical",
                    helpVertDesc: "Le graphique montre votre vol de profil. La ligne verte/violette est l'altitude. Les barbules indiquent le vent.",
                    helpAi: "Optimisation IA",
                    helpAiDesc: "(Clé API requise) L'IA simule des milliers de vols pour trouver la meilleure altitude et route.",
                    gotIt: "Compris",
                    eduWarning: "USAGE ÉDUCATIF UNIQUEMENT - UTILISEZ DES OUTILS CERTIFIÉS POUR LE RÉEL",
                    apiKey: "Clé API (Optionnelle)",
                    getKey: "Obtenir Clé",
                    aiError: "Service IA Échoué",
                    close: "FERMER"
                },
                es: {
                    title: "Ruta de Vuelo",
                    origin: "ORIGEN",
                    dest: "DESTINO",
                    aircraft: "AERONAVE",
                    dep: "SALIDA (UTC)",
                    minAlt: "ALT MIN",
                    maxAlt: "ALT MAX",
                    climbPwr: "POTENCIA ASCENSO %",
                    cruisePwr: "POTENCIA CRUCERO %",
                    fuelUnits: "UNIDADES COMBUSTIBLE",
                    calc: "CALCULAR VUELO",
                    calcing: "CALCULANDO...",
                    aiOpt: "OPTIMIZAR IA",
                    aiThinking: "IA PENSANDO...",
                    aiOptimized: "OPTIMIZADO POR IA",
                    reset: "RESTAURAR RUTA DIRECTA",
                    ete: "ETE",
                    fuel: "COMBUSTIBLE",
                    dist: "DIST",
                    eta: "ETA (UTC)",
                    climbTas: "TAS Ascenso",
                    cruiseTas: "TAS Crucero",
                    customRoute: "RUTA PERSONALIZADA",
                    waypoints: "Puntos",
                    vertProfile: "PERFIL VERTICAL",
                    aiStrategy: "Estrategia IA",
                    deviateLeft: "DESVIAR IZQUIERDA",
                    deviateRight: "DESVIAR DERECHA",
                    stayCenter: "CENTRO",
                    planAlt: "Alt Plan",
                    map: "MAPA",
                    sat: "SAT",
                    altitude: "ALTITUD",
                    helpTitle: "Cómo Usar",
                    helpStart: "Empezando",
                    helpStartDesc: "Ingrese códigos ICAO de 4 letras. Seleccione su avión y haga clic en Calcular Vuelo.",
                    helpEdit: "Edición Elástica",
                    helpEditDesc: "Pase el mouse sobre la ruta en el mapa. Arrastre el controlador blanco para desviar su ruta y crear un punto de paso.",
                    helpVert: "Perfil Vertical",
                    helpVertDesc: "El gráfico muestra su vuelo de perfil. La línea verde/violeta es la altitud. Las barbas muestran el viento.",
                    helpAi: "Optimización IA",
                    helpAiDesc: "(Requiere clave API) La IA simula miles de vuelos para encontrar la mejor altitud y ruta.",
                    gotIt: "Entendido",
                    eduWarning: "SOLO USO EDUCATIVO - USE HERRAMIENTAS CERTIFICADAS PARA VUELO REAL",
                    apiKey: "Clave API (Opcional)",
                    getKey: "Obtener Clave",
                    aiError: "Fallo Servicio IA",
                    close: "CERRAR"
                },
                de: {
                    title: "Flugpfad",
                    origin: "HERKUNFT",
                    dest: "ZIEL",
                    aircraft: "FLUGZEUG",
                    dep: "ABFLUG (UTC)",
                    minAlt: "MIN HÖHE",
                    maxAlt: "MAX HÖHE",
                    climbPwr: "STEIGLEISTUNG %",
                    cruisePwr: "REISELEISTUNG %",
                    fuelUnits: "KRAFTSTOFFEINHEITEN",
                    calc: "FLUG BERECHNEN",
                    calcing: "BERECHNE...",
                    aiOpt: "KI OPTIMIERUNG",
                    aiThinking: "KI DENKT...",
                    aiOptimized: "KI OPTIMIERT",
                    reset: "DIREKTROUTE WIEDERHERSTELLEN",
                    ete: "ETE",
                    fuel: "TREIBSTOFF",
                    dist: "DIST",
                    eta: "ETA (UTC)",
                    climbTas: "Steig TAS",
                    cruiseTas: "Reise TAS",
                    customRoute: "BENUTZERROUTE AKTIV",
                    waypoints: "Wegpunkte",
                    vertProfile: "VERTIKALES PROFIL",
                    aiStrategy: "KI Strategie",
                    deviateLeft: "LINKS ABWEICHEN",
                    deviateRight: "RECHTS ABWEICHEN",
                    stayCenter: "MITTE BLEIBEN",
                    planAlt: "Plan Höhe",
                    map: "KARTE",
                    sat: "SAT",
                    altitude: "HÖHE",
                    helpTitle: "Anleitung",
                    helpStart: "Erste Schritte",
                    helpStartDesc: "Geben Sie 4-stellige ICAO-Codes ein. Wählen Sie Ihr Flugzeug und klicken Sie auf Flug Berechnen.",
                    helpEdit: "Elastische Routenbearbeitung",
                    helpEditDesc: "Fahren Sie mit der Maus über die Flugroute. Ziehen Sie den weißen Griff, um die Route zu ändern und einen Wegpunkt zu erstellen.",
                    helpVert: "Vertikales Profil",
                    helpVertDesc: "Das Diagramm zeigt Ihren Flug von der Seite. Grüne/Lila Linie ist die Höhe. Windfahnen zeigen Windgeschwindigkeit/-richtung.",
                    helpAi: "KI Optimierung",
                    helpAiDesc: "(API-Schlüssel erforderlich) KI simuliert Tausende von Flügen, um die beste Höhe und Route zu finden.",
                    gotIt: "Verstanden",
                    eduWarning: "NUR FÜR BILDUNGSZWECKE - VERWENDEN SIE ZERTIFIZIERTE TOOLS FÜR ECHTE FLÜGE",
                    apiKey: "API-Schlüssel (Optional)",
                    getKey: "Schlüssel holen",
                    aiError: "KI Dienst fehlgeschlagen",
                    close: "SCHLIEßEN"
                }
            };

            const CONSTANTS = {
                R_EARTH_NM: 3440.065,
                GRID_STEP: 50,
                LEVELS: [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 12000, 14000, 16000, 18000, 24000, 30000, 34000, 39000, 45000],
                LEVEL_MAP: {
                    1000: '975hPa', 2000: '925hPa', 3000: '900hPa', 4000: '850hPa', 
                    5000: '850hPa', 6000: '800hPa', 7000: '800hPa', 8000: '750hPa', 
                    9000: '700hPa', 10000: '700hPa', 12000: '600hPa', 14000: '600hPa',
                    16000: '500hPa', 18000: '500hPa', 24000: '400hPa', 30000: '300hPa', 
                    34000: '250hPa', 39000: '200hPa', 45000: '150hPa'
                },
                AIRCRAFT_PERF: {
                    'C172': { name: 'Cessna 172 Skyhawk', climb_rate: 730, climb_spd: 74, cruise_spd: 124, desc_rate: 500, desc_spd: 90, burn: 9 },
                    'PA28': { name: 'Piper Archer II', climb_rate: 667, climb_spd: 76, cruise_spd: 116, desc_rate: 500, desc_spd: 90, burn: 10 },
                    'C182': { name: 'Cessna 182T Skylane', climb_rate: 924, climb_spd: 80, cruise_spd: 145, desc_rate: 500, desc_spd: 100, burn: 13 },
                    'SR22': { name: 'Cirrus SR22', climb_rate: 1270, climb_spd: 95, cruise_spd: 180, desc_rate: 700, desc_spd: 110, burn: 17 },
                    'M20J': { name: 'Mooney M20J', climb_rate: 1000, climb_spd: 90, cruise_spd: 160, desc_rate: 500, desc_spd: 100, burn: 11 }
                }
            };

            const fetchWithTimeout = async (resource, options = {}) => {
                const { timeout = 25000 } = options;
                const controller = new AbortController();
                const id = setTimeout(() => controller.abort(), timeout);
                try {
                    const response = await fetch(resource, { ...options, signal: controller.signal });
                    clearTimeout(id);
                    return response;
                } catch (error) {
                    clearTimeout(id);
                    throw error;
                }
            };

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            const Geo = {
                dist: (lat1, lon1, lat2, lon2) => {
                    const R = CONSTANTS.R_EARTH_NM;
                    const dLat = (lat2 - lat1) * Math.PI / 180;
                    const dLon = (lon2 - lon1) * Math.PI / 180;
                    const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
                    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                },
                bearing: (lat1, lon1, lat2, lon2) => {
                    const y = Math.sin((lon2 - lon1) * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180);
                    const x = Math.cos(lat1*Math.PI/180)*Math.sin(lat2*Math.PI/180) - Math.sin(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.cos((lon2-lon1)*Math.PI/180);
                    return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
                },
                offset: (lat, lon, d, brg) => {
                    const R = CONSTANTS.R_EARTH_NM;
                    const lat1 = lat * Math.PI / 180, lon1 = lon * Math.PI / 180, brgRad = brg * Math.PI / 180;
                    const lat2 = Math.asin(Math.sin(lat1)*Math.cos(d/R) + Math.cos(lat1)*Math.sin(d/R)*Math.cos(brgRad));
                    const lon2 = lon1 + Math.atan2(Math.sin(brgRad)*Math.sin(d/R)*Math.cos(lat1), Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat2));
                    return { lat: lat2*180/Math.PI, lon: lon2*180/Math.PI };
                },
                densify: (p1, p2, step) => {
                    const d = Geo.dist(p1.lat, p1.lon, p2.lat, p2.lon);
                    const steps = Math.ceil(d / step);
                    if (steps <= 1) return [p1, p2];
                    const pts = [];
                    const brg = Geo.bearing(p1.lat, p1.lon, p2.lat, p2.lon);
                    for(let i=0; i<=steps; i++) {
                        const dist = (i/steps) * d;
                        pts.push(Geo.offset(p1.lat, p1.lon, dist, brg));
                    }
                    return pts;
                },
                formatTime: (date) => {
                    // Force UTC formatting since all dates are treated as UTC
                    const h = date.getUTCHours().toString().padStart(2, '0');
                    const m = date.getUTCMinutes().toString().padStart(2, '0');
                    return `${h}:${m}`;
                },
                formatDuration: (hours) => {
                    const h = Math.floor(hours);
                    const m = Math.round((hours - h) * 60);
                    return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
                },
                getAtmosphereFactor: (altFt) => {
                    const lapse = 1 - (0.0000068756 * altFt);
                    if (lapse <= 0) return 0;
                    return Math.pow(lapse, 5.256);
                }
            };

            const Physics = {
                calculateProfile: (grid, wx, perf, origin, dest, strategy, level, depMs, customRoute = []) => {
                    let majorWaypoints = [];
                    let routeType = 'STANDARD';

                    if (customRoute && customRoute.length > 0) {
                        majorWaypoints = [
                            { ...origin, type: 'ORIGIN', name: origin.icao },
                            ...customRoute.map((p, i) => ({ ...p, type: 'WP', name: `WP${i+1}` })),
                            { ...dest, type: 'DEST', name: dest.icao }
                        ];
                        routeType = 'CUSTOM';
                    } else {
                        majorWaypoints = [
                            { ...origin, type: 'ORIGIN', name: origin.icao },
                            { ...dest, type: 'DEST', name: dest.icao }
                        ];
                    }

                    let points = [];
                    
                    if (routeType === 'CUSTOM') {
                        for(let i=0; i<majorWaypoints.length-1; i++) {
                            const segment = Geo.densify(majorWaypoints[i], majorWaypoints[i+1], CONSTANTS.GRID_STEP);
                            if(i > 0) segment.shift();
                            segment.forEach(pt => {
                                let minD = Infinity, bestG = null;
                                grid.forEach(g => {
                                    const d = Geo.dist(g.lat, g.lon, pt.lat, pt.lon);
                                    if(d < minD) { minD = d; bestG = g; }
                                });
                                pt.gIdx = bestG ? bestG.gIdx : 0;
                                pt.legIdx = i; 
                                pt.type = (i === 0 && pt === segment[0]) ? 'ORIGIN' : 'SimPt';
                            });
                            points.push(...segment);
                        }
                    } else {
                        const maxIdx = grid[grid.length-1].idx;
                        const startPt = grid.find(p => p.type === 'C' && p.idx === 0);
                        const endPt = grid.find(p => p.type === 'C' && p.idx === maxIdx);
                        
                        let rawPts = (strategy === 'C') 
                            ? grid.filter(p => p.type === 'C') 
                            : [startPt, ...grid.filter(p => p.type === strategy && p.idx > 0 && p.idx < maxIdx), endPt];
                        
                        if(rawPts.length < 3 && strategy !== 'C') rawPts = grid.filter(p => p.type === 'C');

                        points = rawPts.map(p => ({ ...p, legIdx: 0 })); 
                    }

                    let totalDist = 0;
                    points = points.map((pt, i) => {
                        let seg = 0;
                        if (i > 0) seg = Geo.dist(points[i-1].lat, points[i-1].lon, pt.lat, pt.lon);
                        totalDist += seg;
                        return { ...pt, segDist: seg };
                    });

                    const climbRate = perf.climb_rate || 500;
                    const climbSpd = perf.climb_spd || 80;
                    const descRate = perf.desc_rate || 500;
                    const descSpd = perf.desc_spd || 90;
                    const cruiseSpd = perf.cruise_spd || 120;
                    
                    let simAlt = Number(origin.elev)||0, simDist = 0, simTime = 0, loop = 0;
                    let chart = [{dist:0, alt:simAlt}];
                    
                    while(simAlt < level && loop++ < 2000) {
                        const f = Geo.getAtmosphereFactor(simAlt);
                        const r = Math.max(100, climbRate * f);
                        let dAlt = Math.min(500, level - simAlt);
                        let dt = dAlt / r; 
                        let dd = (climbSpd / 60) * dt; 
                        simAlt += dAlt; simDist += dd; simTime += dt;
                        chart.push({dist: simDist, alt: simAlt});
                    }
                    const climbD = simDist;
                    
                    const descD = (Math.max(0, level - (Number(dest.elev)||0)) / descRate / 60) * descSpd;
                    
                    if(climbD < totalDist - descD) {
                        chart.push({dist: totalDist - descD, alt: level});
                    }
                    chart.push({dist: totalDist, alt: Number(dest.elev)||0});

                    let curTime = depMs, curFuel = 0, flown = 0;
                    const waypoints = points.map((pt, i) => {
                        flown += pt.segDist;
                        let alt = level, tas = cruiseSpd;
                        
                        if(flown < climbD) {
                            const pB = chart.findLast(p => p.dist <= flown) || chart[0];
                            const pA = chart.find(p => p.dist > flown) || chart[chart.length-1];
                            alt = (pA.dist > pB.dist) ? pB.alt + (pA.alt - pB.alt)*((flown-pB.dist)/(pA.dist-pB.dist)) : pA.alt;
                            tas = climbSpd;
                        } else if(flown > totalDist - descD) {
                            alt = level - ((level - (Number(dest.elev)||0)) * ((flown - (totalDist-descD))/descD));
                            tas = descSpd;
                        }
                        
                        const w = wx[pt.gIdx];
                        let winds = {};
                        if(w && w.hourly) {
                            // Use UTC hours to align with Open-Meteo's default UTC response
                            const hourIndex = new Date(curTime).getUTCHours() % 24;
                            CONSTANTS.LEVELS.forEach(lvl => {
                                const k = CONSTANTS.LEVEL_MAP[lvl];
                                if(w.hourly[`wind_speed_${k}`]) {
                                    const spd = w.hourly[`wind_speed_${k}`][hourIndex] !== undefined ? w.hourly[`wind_speed_${k}`][hourIndex] : w.hourly[`wind_speed_${k}`][0];
                                    const dir = w.hourly[`wind_direction_${k}`][hourIndex] !== undefined ? w.hourly[`wind_direction_${k}`][hourIndex] : w.hourly[`wind_direction_${k}`][0];
                                    winds[lvl] = { spd, dir };
                                }
                            });
                        }
                        
                        const bestW = winds[Object.keys(winds).reduce((a, b) => Math.abs(b - alt) < Math.abs(a - alt) ? b : a, 0)] || {spd:0,dir:0};
                        
                        let crs = 0;
                        if(i < points.length-1) crs = Geo.bearing(pt.lat, pt.lon, points[i+1].lat, points[i+1].lon);
                        else if (i > 0) crs = Geo.bearing(points[i-1].lat, points[i-1].lon, pt.lat, pt.lon);

                        const hw = bestW.spd * Math.cos((bestW.dir - crs) * Math.PI/180);
                        const gs = Math.max(30, tas - hw);
                        const ptEta = curTime;
                        
                        if(i < points.length-1) {
                            const dt = (points[i+1].segDist / gs) * 3600 * 1000;
                            curTime += dt;
                            curFuel += (dt/3600000) * perf.burn;
                        }
                        
                        return { ...pt, alt, winds, totalDist: flown, course: crs, eta: ptEta };
                    });
                    
                    return { 
                        waypoints,
                        majorWaypoints, 
                        chartGeometry: chart, 
                        dist: Math.round(totalDist), 
                        time: curTime - depMs, 
                        fuel: curFuel, 
                        arrival: curTime 
                    };
                }
            };

            const getBarbSVGString = (spd, dir) => {
                let color = '#10b981'; 
                if(spd > 20) color = '#eab308'; 
                if(spd > 40) color = '#ef4444'; 
                
                let paths = '';
                const pennants = Math.floor(spd / 50); let r = spd % 50;
                const tens = Math.floor(r / 10); r %= 10;
                const fives = r >= 5 ? 1 : 0;
                
                let y = 2; 
                for(let i=0; i<pennants; i++) { 
                    paths += `<polygon points="20,${y} 20,${y+10} 10,${y+5}" fill="${color}" stroke="none"/>`; 
                    y+=12; 
                }
                for(let i=0; i<tens; i++) { 
                    paths += `<line x1="20" y1="${y}" x2="10" y2="${y+3}" stroke="${color}" stroke-width="2"/>`; 
                    y+=5; 
                }
                if(fives) { 
                    paths += `<line x1="20" y1="${y}" x2="15" y2="${y+3}" stroke="${color}" stroke-width="2"/>`; 
                }
                return `<svg width="40" height="40" viewBox="0 0 40 40" style="transform: rotate(${dir}deg); overflow: visible;"><circle cx="20" cy="20" r="2" fill="${color}"/><line x1="20" y1="20" x2="20" y2="2" stroke="${color}" stroke-width="2"/>${paths}</svg>`;
            };

            const Icon = ({ name, size=16, className="" }) => {
                const ref = useRef(null);
                const [loaded, setLoaded] = useState(false);

                useEffect(() => {
                    if (!window.lucide || !window.lucide.createIcons) {
                        const check = setInterval(() => { 
                            if (window.lucide && window.lucide.createIcons) { 
                                setLoaded(true); 
                                clearInterval(check); 
                            } 
                        }, 100);
                        setTimeout(() => clearInterval(check), 3000); 
                        return () => clearInterval(check);
                    } else setLoaded(true);
                }, []);
                
                useEffect(() => {
                    if (!loaded || !ref.current || !window.lucide) return;
                    if (!window.lucide.icons[name]) {
                        ref.current.innerHTML = `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="${className}"><circle cx="12" cy="12" r="10"/></svg>`;
                        return;
                    }
                    try {
                        const i = document.createElement('i');
                        i.setAttribute('data-lucide', name);
                        ref.current.innerHTML = '';
                        ref.current.appendChild(i);
                        window.lucide.createIcons({ 
                            root: ref.current, 
                            icons: { [name]: window.lucide.icons[name] }, 
                            attrs: { class: className, width: size, height: size, "stroke-width": 2 } 
                        });
                    } catch(e) { ref.current.innerText = name; }
                }, [name, size, className, loaded]);
                
                return <span ref={ref} className="inline-flex items-center justify-center text-[10px]" style={{ width: size, height: size }}></span>;
            };

            const Services = {
                fetchAirport: async (icao) => {
                    try {
                        const res = await fetchWithTimeout(`station_lookup.php?icao=${icao}`);
                        const d = await res.json();
                        if(!d.lat) throw new Error("Not Found");
                        return { ...d, lat: parseFloat(d.lat), lon: parseFloat(d.lon), elev: parseInt(d.elev_ft) };
                    } catch (e) {
                        throw new Error(`Airport ${icao} fetch failed: ${e.message}`); 
                    }
                },
                
                fetchPerf: async (type, key) => {
                    if (!key && CONSTANTS.AIRCRAFT_PERF[type]) {
                        return CONSTANTS.AIRCRAFT_PERF[type];
                    }
                    if (key) {
                         try {
                            const prompt = `Return a JSON object for standard performance of aircraft "${type}". Fields: climb_rate(int), climb_spd(int), cruise_spd(int), desc_rate(int), desc_spd(int), burn(int). Return ONLY JSON.`;
                            const res = await fetchWithTimeout(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${key}`, {
                                method: 'POST', headers: {'Content-Type': 'application/json'},
                                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                            });
                            
                            if (res.status === 400 || res.status === 403) {
                                throw new Error("INVALID_API_KEY");
                            }
                            
                            const d = await res.json();
                            const text = d.candidates[0].content.parts[0].text;
                            const jsonStr = text.match(/\{[\s\S]*\}/)[0];
                            return JSON.parse(jsonStr);
                        } catch (e) {
                            if (e.message === "INVALID_API_KEY") throw e; 
                            if (CONSTANTS.AIRCRAFT_PERF[type]) return CONSTANTS.AIRCRAFT_PERF[type];
                            return CONSTANTS.AIRCRAFT_PERF['C172'];
                        }
                    }
                    return CONSTANTS.AIRCRAFT_PERF['C172'];
                },
                
                fetchWeather: async (grid, minAlt, maxAlt, date, onProgress, manualWind) => {
                    if (manualWind && manualWind.speed > 0) {
                        return Services.generateStandardAtmosphere(grid);
                    }
                    const relevantLevels = CONSTANTS.LEVELS.filter(l => l >= minAlt - 2000 && l <= maxAlt + 2000);
                    if (relevantLevels.length === 0) relevantLevels.push(CONSTANTS.LEVELS.find(l => l >= minAlt) || 1000);
                    const relevantKeys = [...new Set(relevantLevels.map(l => CONSTANTS.LEVEL_MAP[l]).filter(Boolean))];
                    
                    // Fallback to ensure we always request at least one level to avoid empty API calls
                    if(relevantKeys.length === 0) relevantKeys.push('975hPa');

                    const vars = relevantKeys.flatMap(p => [`wind_speed_${p}`, `wind_direction_${p}`]).join(',');

                    // Reduced batch size to improve reliability
                    const batchSize = 3; 
                    const chunks = [];
                    for(let i=0; i<grid.length; i+=batchSize) chunks.push(grid.slice(i, i+batchSize));
                    
                    let allResults = [];
                    let hasFailed = false;
                    
                    // Format date for API - date input is treated as UTC
                    const dateStr = date.toISOString().split('T')[0];

                    for (let i = 0; i < chunks.length; i++) {
                        if (hasFailed) break; 
                        if (onProgress) onProgress(i * batchSize, grid.length);
                        const chunk = chunks[i];
                        const lats = chunk.map(p=>p.lat.toFixed(2)).join(',');
                        const lons = chunk.map(p=>p.lon.toFixed(2)).join(',');
                        
                        let success = false;
                        let responseData = null;

                        try {
                            // DIRECT CONNECTION - Removing Proxy to ensure correct date handling
                            const directUrl = `https://api.open-meteo.com/v1/forecast?latitude=${lats}&longitude=${lons}&hourly=${vars}&wind_speed_unit=kn&start_date=${dateStr}&end_date=${dateStr}`;
                            // Increased timeout for direct connection
                            const res = await fetchWithTimeout(directUrl, { timeout: 30000 });
                            if (res.ok) {
                                const d = await res.json();
                                if(d.error) {
                                    console.error("OpenMeteo Error:", d);
                                    throw new Error("OpenMeteo Error");
                                }
                                
                                // Validation: Check if returned data matches requested date
                                const returnedArray = Array.isArray(d) ? d : [d];
                                const firstPt = returnedArray[0];
                                if (firstPt && firstPt.hourly && firstPt.hourly.time) {
                                    const firstTime = firstPt.hourly.time[0]; // Expect "YYYY-MM-DDTHH:00"
                                    if (firstTime && !firstTime.startsWith(dateStr)) {
                                        console.warn(`Weather Date Mismatch! Requested: ${dateStr}, Got: ${firstTime}`);
                                        // We treat this as a failure so fallback logic triggers, ensuring user knows
                                        throw new Error("Date Mismatch");
                                    }
                                }

                                responseData = returnedArray;
                                success = true;
                            } else {
                                console.error("OpenMeteo HTTP Error:", res.status, res.statusText);
                            }
                        } catch(e) { 
                            console.error("Weather fetch failed for chunk", i, e); 
                        }

                        if (success && responseData) allResults.push(...responseData);
                        else hasFailed = true;
                        
                        await sleep(200); 
                    }
                    
                    if (hasFailed || allResults.length === 0) return Services.generateStandardAtmosphere(grid); 
                    return allResults;
                },
                
                generateStandardAtmosphere: (grid) => {
                    return grid.map(pt => {
                        const fakeWx = { hourly: {} };
                        // Simple wind shear model: 5kts at surface, increasing 2kts per 1000ft
                        // Direction 270 (West wind standard)
                        CONSTANTS.LEVELS.forEach(lvl => {
                             const key = CONSTANTS.LEVEL_MAP[lvl];
                             if(!key) return;
                             // distinct speeds per level, but constant over time
                             const spd = Math.min(100, 10 + (lvl / 1000) * 2); 
                             fakeWx.hourly[`wind_speed_${key}`] = new Array(24).fill(spd);
                             fakeWx.hourly[`wind_direction_${key}`] = new Array(24).fill(270);
                        });
                        return fakeWx;
                    });
                },

                optimizeRoute: async (options, key, lang) => {
                    if(!key) throw new Error("NO_KEY");
                    
                    const optionsText = options.map((opt, i) => 
                        `Option ${i+1}: Strategy=${opt.strategy}, Altitude=${opt.alt}ft, FlightTime=${opt.timeFormatted}, Fuel=${opt.fuel.toFixed(1)}`
                    ).join('\n');

                    // Request reasoning in the target language
                    const languageName = { en: "English", fr: "French", es: "Spanish", de: "German" }[lang] || "English";

                    const prompt = `
Act as an expert aircraft dispatcher.
I have simulated flight paths for different altitudes and route strategies (Center, Left Deviation, Right Deviation).
Here are the top candidates for the SHORTEST TIME in air:

${optionsText}

Select the absolute best option for minimum flight time.
Return a JSON object: { "strategy": "L"|"C"|"R", "alt": number, "reasoning": "Concise explanation (max 20 words) citing time/fuel savings in ${languageName}." }
Note: L=Left Deviation, R=Right Deviation, C=Center.
`;
                    
                    const res = await fetchWithTimeout(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${key}`, {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });
                    
                    if (res.status === 400 || res.status === 403) throw new Error("INVALID_KEY");
                    
                    const d = await res.json();
                    if (!d.candidates || !d.candidates[0]) throw new Error("AI_ERROR");
                    return JSON.parse(d.candidates[0].content.parts[0].text.match(/\{[\s\S]*\}/)[0]);
                }
            };

            const MapView = ({ data, profile, displayAlt, setDisplayAlt, minAlt, maxAlt, mapType, setMapType, onAddWaypoint, className, t }) => {
                const mapRef = useRef(null);
                const layerRef = useRef(null);
                const interactionLayerRef = useRef(null); // Separate layer for interaction
                const tileLayerRef = useRef(null);
                const [mouseInfo, setMouseInfo] = useState(null);
                const dataRef = useRef(data);
                const profileRef = useRef(profile);
                const onAddWaypointRef = useRef(onAddWaypoint);
                const isDraggingRef = useRef(false);
                const isHoveringHandleRef = useRef(false);
                const displayAltRef = useRef(displayAlt);
                const dragMarkerRef = useRef(null);
                const dragLineRef = useRef(null);
                const hoverLegRef = useRef(null);
                const mapInstanceRef = useRef(null);

                useEffect(() => { dataRef.current = data; }, [data]);
                useEffect(() => { profileRef.current = profile; }, [profile]);
                useEffect(() => { onAddWaypointRef.current = onAddWaypoint; }, [onAddWaypoint]);
                useEffect(() => { displayAltRef.current = displayAlt; }, [displayAlt]);

                const getClosestPointOnSegment = (p, a, b) => {
                    const atob = { x: b.x - a.x, y: b.y - a.y };
                    const atop = { x: p.x - a.x, y: p.y - a.y };
                    const len2 = atob.x * atob.x + atob.y * atob.y;
                    if (len2 === 0) return a;
                    let t = (atop.x * atob.x + atop.y * atob.y) / len2;
                    t = Math.max(0, Math.min(1, t));
                    return { x: a.x + t * atob.x, y: a.y + t * atob.y, t };
                };

                // Zoom to bounds when profile calculates
                useEffect(() => {
                    if (profile && mapRef.current && mapRef.current.leafletMap) {
                        const map = mapRef.current.leafletMap;
                        const pts = profile.waypoints.map(p => [p.lat, p.lon]);
                        if (pts.length > 0) {
                            const bounds = L.latLngBounds(pts);
                            map.fitBounds(bounds, { padding: [50, 50], animate: true });
                        }
                    }
                }, [profile?.stats?.arrival]); 

                useEffect(() => {
                    if(!mapRef.current) return;
                    const map = L.map(mapRef.current, { zoomControl: false }).setView([0,0], 2);
                    mapInstanceRef.current = map;
                    L.control.zoom({ position: 'bottomright' }).addTo(map);
                    layerRef.current = L.layerGroup().addTo(map);
                    interactionLayerRef.current = L.layerGroup().addTo(map);
                    const ro = new ResizeObserver(() => map.invalidateSize());
                    ro.observe(mapRef.current);
                    
                    map.on('mousemove', (e) => {
                        const d = dataRef.current;
                        const prof = profileRef.current;
                        
                        // 1. Hover info for wind/alt (existing logic)
                        if(d && d.grid) {
                            let minDist = Infinity, nearest = null;
                            d.grid.forEach((pt, i) => {
                                const dist = Geo.dist(e.latlng.lat, e.latlng.lng, pt.lat, pt.lon);
                                if(dist < minDist) { minDist = dist; nearest = { ...pt, wx: d.wx[i] }; }
                            });
                            
                            if(nearest && minDist < 50 && nearest.wx && nearest.wx.hourly) {
                                const avail = CONSTANTS.LEVELS;
                                const currentAlt = displayAltRef.current; // Use ref to get latest displayAlt
                                const closest = avail.reduce((p, c) => Math.abs(c-currentAlt) < Math.abs(p-currentAlt) ? c : p);
                                const key = CONSTANTS.LEVEL_MAP[closest];
                                const h = new Date().getHours() % 24; 
                                const s = nearest.wx.hourly[`wind_speed_${k}`]?.[h] || 0;
                                const dr = nearest.wx.hourly[`wind_direction_${k}`]?.[h] || 0;
                                setMouseInfo({ spd: s, dir: dr, alt: closest });
                            } else setMouseInfo(null);
                        }
                    });

                    // Initialize Drag Marker - LARGE hit area with centered visual
                    const dragIcon = L.divIcon({ 
                        className: 'drag-handle-container', 
                        html: '<div class="drag-handle-visual"></div>',
                        iconSize: [40, 40], // Large hit area
                        iconAnchor: [20, 20] 
                    });
                    
                    const dm = L.marker([0,0], { 
                        icon: dragIcon, 
                        interactive: true, 
                        draggable: true, 
                        opacity: 0, 
                        zIndexOffset: 2000 // High z-index to sit on top of everything
                    }).addTo(map);
                    
                    dragMarkerRef.current = dm;

                    // IMPORTANT: Prevent map dragging when hovering the handle
                    const disableMapDrag = () => { if(mapInstanceRef.current) mapInstanceRef.current.dragging.disable(); };
                    const enableMapDrag = () => { if(!isDraggingRef.current && mapInstanceRef.current) mapInstanceRef.current.dragging.enable(); };

                    dm.on('mouseover', () => {
                        isHoveringHandleRef.current = true;
                        disableMapDrag();
                    });
                    dm.on('mousedown', disableMapDrag);
                    dm.on('mouseout', () => {
                        isHoveringHandleRef.current = false;
                        enableMapDrag();
                    });

                    // Drag Events
                    dm.on('dragstart', (e) => {
                        isDraggingRef.current = true;
                        // Ensure map dragging is disabled during interaction
                        if(mapInstanceRef.current) mapInstanceRef.current.dragging.disable();
                        
                        const legIdx = hoverLegRef.current;
                        if (legIdx === null || !profileRef.current) return;
                        
                        // Anchors are the Major Waypoints of this leg
                        const p1 = profileRef.current.majorWaypoints[legIdx];
                        const p2 = profileRef.current.majorWaypoints[legIdx+1];
                        
                        // Create visual elastic lines
                        const line = L.polyline([
                            [p1.lat, p1.lon],
                            e.target.getLatLng(),
                            [p2.lat, p2.lon]
                        ], { color: 'white', weight: 2, dashArray: '5, 10' }).addTo(map);
                        dragLineRef.current = line;
                    });

                    dm.on('drag', (e) => {
                        if(dragLineRef.current) {
                            const latlngs = dragLineRef.current.getLatLngs();
                            latlngs[1] = e.target.getLatLng();
                            dragLineRef.current.setLatLngs(latlngs);
                        }
                    });

                    dm.on('dragend', (e) => {
                        isDraggingRef.current = false;
                        enableMapDrag();
                        if (dragLineRef.current) {
                            dragLineRef.current.remove();
                            dragLineRef.current = null;
                        }
                        const legIdx = hoverLegRef.current;
                        if (legIdx !== null && onAddWaypointRef.current) {
                            const newPt = e.target.getLatLng();
                            // Insert at legIdx + 1 (since legs are 0-indexed: leg 0 is between WP0 and WP1, so insert at index 1)
                            onAddWaypointRef.current(newPt.lat, newPt.lng, legIdx + 1);
                        }
                        dm.setOpacity(0);
                    });

                    mapRef.current.leafletMap = map;
                }, []); 

                useEffect(() => {
                    const map = mapRef.current?.leafletMap;
                    if(!map) return;
                    if(tileLayerRef.current) tileLayerRef.current.remove();
                    let url = mapType === 'satellite' ? 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}' : 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
                    let attrib = mapType === 'satellite' ? 'Tiles &copy; Esri &mdash; Source: Esri' : '&copy; OpenStreetMap contributors';
                    tileLayerRef.current = L.tileLayer(url, { attribution: attrib }).addTo(map);
                }, [mapType]);

                useEffect(() => {
                    const fg = layerRef.current;
                    const ig = interactionLayerRef.current;
                    if(!fg || !ig || !data) return;
                    
                    fg.clearLayers();
                    ig.clearLayers();
                    
                    data.grid.forEach((pt, i) => {
                        const wx = data.wx[i];
                        if(!wx || !wx.hourly) return;
                        const closest = CONSTANTS.LEVELS.reduce((p, c) => Math.abs(c-displayAlt) < Math.abs(p-displayAlt) ? c : p);
                        const k = CONSTANTS.LEVEL_MAP[closest];
                        const h = new Date().getHours() % 24;
                        const s = wx.hourly[`wind_speed_${k}`]?.[h];
                        const d = wx.hourly[`wind_direction_${k}`]?.[h];
                        
                        if (s !== undefined && d !== undefined) {
                            const icon = L.divIcon({ html: getBarbSVGString(s, d), className: 'wind-icon', iconSize: [40,40], iconAnchor: [20,20] });
                            L.marker([pt.lat, pt.lon], { icon }).addTo(fg);
                        }
                    });
                    
                    if(profile) {
                        const pts = profile.waypoints.map(w => [w.lat, w.lon]);
                        L.polyline(pts, { color: profile.isOptimized ? '#a855f7' : '#10b981', weight: 4 }).addTo(fg);
                        
                        // Interaction Lines (Invisible Hit Areas)
                        const legs = {};
                        profile.waypoints.forEach(wp => {
                            if (!legs[wp.legIdx]) legs[wp.legIdx] = [];
                            legs[wp.legIdx].push([wp.lat, wp.lon]);
                        });

                        Object.keys(legs).forEach(legIdxKey => {
                            const legIdx = parseInt(legIdxKey);
                            const legPts = legs[legIdx];
                            if (legPts.length < 2) return;

                            const hitLine = L.polyline(legPts, { 
                                weight: 40, // THICK invisible line
                                opacity: 0, 
                                interactive: true 
                            }).addTo(ig);

                            hitLine.on('mousemove', (e) => {
                                if (isDraggingRef.current) return;
                                if (dragMarkerRef.current) {
                                    
                                    // SNAPPING LOGIC - Projects mouse point onto closest segment
                                    let minD = Infinity;
                                    let closestLatLng = e.latlng;
                                    const map = mapRef.current.leafletMap;

                                    // Iterate segments of this specific leg to find closest point
                                    for (let i = 0; i < legPts.length - 1; i++) {
                                        const p1 = L.latLng(legPts[i]);
                                        const p2 = L.latLng(legPts[i+1]);
                                        
                                        const p1Px = map.latLngToLayerPoint(p1);
                                        const p2Px = map.latLngToLayerPoint(p2);
                                        const mousePx = e.layerPoint;
                                        
                                        // Leaflet internal utility
                                        const closestPx = L.LineUtil.closestPointOnSegment(mousePx, p1Px, p2Px);
                                        const dist = mousePx.distanceTo(closestPx);
                                        
                                        if (dist < minD) {
                                            minD = dist;
                                            closestLatLng = map.layerPointToLatLng(closestPx);
                                        }
                                    }

                                    dragMarkerRef.current.setLatLng(closestLatLng);
                                    dragMarkerRef.current.setOpacity(1);
                                    hoverLegRef.current = legIdx;
                                }
                            });
                            
                            // Hide marker when leaving the specific leg line
                            hitLine.on('mouseout', (e) => {
                                setTimeout(() => {
                                    if (!isDraggingRef.current && !isHoveringHandleRef.current) {
                                        if (dragMarkerRef.current) dragMarkerRef.current.setOpacity(0);
                                    }
                                }, 100); // Small grace period
                            });
                        });

                        if (profile.majorWaypoints) {
                            profile.majorWaypoints.forEach((wp, i) => {
                                if (i > 0 && i < profile.majorWaypoints.length - 1) {
                                    const icon = L.divIcon({ 
                                        html: `<span>${i}</span>`, 
                                        className: 'waypoint-icon', 
                                        iconSize: [20,20], 
                                        iconAnchor: [10,10] 
                                    });
                                    L.marker([wp.lat, wp.lon], { icon }).addTo(fg);
                                }
                            });
                        }
                    }
                    
                    if(data.origin) L.circleMarker([data.origin.lat, data.origin.lon], {color: 'white', radius: 5}).addTo(fg);
                    if(data.dest) L.circleMarker([data.dest.lat, data.dest.lon], {color: 'white', radius: 5}).addTo(fg);
                }, [data, profile, displayAlt]);

                return (
                    <div className={`relative w-full rounded-xl overflow-hidden shadow-2xl border border-slate-700 bg-slate-900 group ${className || 'h-[500px]'}`}
                         onMouseLeave={() => {
                             if(dragMarkerRef.current && !isDraggingRef.current) dragMarkerRef.current.setOpacity(0);
                         }}
                    >
                        <div ref={mapRef} className="w-full h-full z-0" />
                        <div className="absolute top-4 right-4 z-[1000] flex flex-col gap-2 items-end" onMouseDown={e=>e.stopPropagation()} onDoubleClick={e=>e.stopPropagation()} onScroll={e=>e.stopPropagation()}>
                            <div className="flex bg-slate-900/90 rounded border border-slate-700 p-1 gap-1">
                                <button onClick={()=>setMapType('street')} className={`px-2 py-1 text-[10px] font-bold rounded transition-colors ${mapType==='street' ? 'bg-blue-600 text-white' : 'text-slate-400 hover:text-white'}`}>{t('map')}</button>
                                <button onClick={()=>setMapType('satellite')} className={`px-2 py-1 text-[10px] font-bold rounded transition-colors ${mapType==='satellite' ? 'bg-blue-600 text-white' : 'text-slate-400 hover:text-white'}`}>{t('sat')}</button>
                            </div>
                            <div className="bg-slate-900/90 rounded border border-slate-700 p-2 flex flex-col items-center select-none">
                                <label className="text-[9px] text-slate-400 font-bold mb-1">{t('altitude')}</label>
                                <div className="flex items-center gap-2">
                                    <button className="p-1 hover:text-blue-400 active:scale-90 transition-transform" onClick={()=>setDisplayAlt(d => Math.max(minAlt, d-1000))}><Icon name="Minus" size={16}/></button>
                                    <span className="font-mono text-xs w-12 text-center">{displayAlt}</span>
                                    <button className="p-1 hover:text-blue-400 active:scale-90 transition-transform" onClick={()=>setDisplayAlt(d => Math.min(maxAlt, d+1000))}><Icon name="Plus" size={16}/></button>
                                </div>
                            </div>
                        </div>
                        {mouseInfo && (
                            <div className="absolute bottom-4 left-4 z-[500] bg-slate-900/90 p-2 rounded border border-slate-700 text-xs font-mono pointer-events-none">
                                <div className="text-emerald-400 font-bold">{mouseInfo.dir.toFixed(0)}° @ {Math.round(mouseInfo.spd)}kt</div>
                                <div className="text-slate-500">{mouseInfo.alt} FT</div>
                            </div>
                        )}
                    </div>
                );
            };

            const ProfileView = ({ profile, displayAlt, setDisplayAlt, minAlt, maxAlt, origin, dest, t }) => {
                const svgRef = useRef(null);
                const [cursor, setCursor] = useState(null);
                const [cursorData, setCursorData] = useState(null);

                if(!profile || !origin || !dest) return <div className="h-[200px] lg:h-[300px] flex items-center justify-center text-slate-500 panel rounded-xl">Generate Flight to View Profile</div>;

                const w = 800, h = 300, p = 40;
                const distTotal = profile.stats.distance;
                const maxH = Math.max(maxAlt, ...profile.chartGeometry.map(p=>p.alt)) + 2000;
                const x = d => p + (d / distTotal) * (w - p*2);
                const y = a => h - p - (a / maxH) * (h - p*2);
                const pathD = profile.chartGeometry.map((pt, i) => `${i===0?'M':'L'} ${x(pt.dist)} ${y(pt.alt)}`).join(' ');
                
                const field = [];
                const levels = CONSTANTS.LEVELS.filter(l => l >= minAlt && l <= maxAlt);

                profile.waypoints.forEach((wp, i) => {
                    levels.forEach(lvl => {
                        const wind = wp.winds[lvl];
                        if(wind) {
                            const rot = wind.dir - wp.course + 90;
                            const color = wind.spd > 40 ? '#ef4444' : (wind.spd > 20 ? '#fbbf24' : '#10b981');
                            field.push(
                                <g key={`${i}-${lvl}`} transform={`translate(${x(wp.totalDist)},${y(lvl)})`} >
                                    <g transform={`rotate(${rot})`} opacity="0.6">
                                        <line x1="0" y1="0" x2="0" y2="-15" stroke={color} strokeWidth="1.5" />
                                        {wind.spd>=10 && <line x1="0" y1="-15" x2="-8" y2="-12" stroke={color} strokeWidth="1.5" />}
                                        {wind.spd>=20 && <line x1="0" y1="-11" x2="-8" y2="-8" stroke={color} strokeWidth="1.5" />}
                                    </g>
                                </g>
                            );
                        }
                    });
                });

                const timeTicksArray = [];
                if(profile.stats.arrival && profile.stats.departure) {
                    const duration = (new Date(profile.stats.arrival) - new Date(profile.stats.departure));
                    let interval = 15 * 60 * 1000; 
                    if(duration > 2 * 3600 * 1000) interval = 30 * 60 * 1000;
                    let t = Math.ceil(new Date(profile.stats.departure).getTime() / interval) * interval;
                    const endT = new Date(profile.stats.arrival).getTime();
                    while(t < endT) {
                        const idx = profile.waypoints.findIndex(wp => wp.eta >= t);
                        if(idx > 0) {
                            const p1 = profile.waypoints[idx-1];
                            const p2 = profile.waypoints[idx];
                            const frac = (t - p1.eta) / (p2.eta - p1.eta);
                            const d = p1.totalDist + frac * (p2.totalDist - p1.totalDist);
                            const label = Geo.formatTime(new Date(t)); 
                            timeTicksArray.push({ dist: d, label });
                        }
                        t += interval;
                    }
                }
                
                const onMove = (e) => {
                    const rect = svgRef.current.getBoundingClientRect();
                    const mx = e.clientX - rect.left;
                    const my = e.clientY - rect.top;
                    if(mx >= p && mx <= w-p && my >= p && my <= h-p) {
                        const alt = maxH * (h - p - my) / (h - p*2);
                        const d = distTotal * (mx - p) / (w - p*2);
                        const closestWp = profile.waypoints.reduce((prev, curr) => Math.abs(curr.totalDist - d) < Math.abs(prev.totalDist - d) ? curr : prev);
                        const closestLevel = levels.reduce((prev, curr) => Math.abs(curr - alt) < Math.abs(prev - alt) ? curr : prev);
                        let info = { dist: d, alt: alt, time: "--:--", wind: "Calm" };
                        if (closestWp) {
                             const eta = new Date(closestWp.eta);
                             info.time = Geo.formatTime(eta);
                             const wind = closestWp.winds[closestLevel];
                             if (wind) {
                                const rad = (wind.dir - closestWp.course + 180) * Math.PI / 180;
                                const comp = Math.round(wind.spd * Math.cos(rad));
                                const label = comp >= 0 ? `+${comp} KT` : `${comp} KT`;
                                info.wind = label;
                             }
                        }
                        setCursorData(info);
                        setCursor({ x: mx, y: my, alt, d });
                    } else { setCursor(null); setCursorData(null); }
                };

                return (
                    <div className="w-full overflow-x-auto pb-2">
                        <div className="min-w-[800px] panel rounded-xl p-4 relative h-[200px] lg:h-[300px]">
                            <div className="flex justify-between items-start mb-2">
                                <h4 className="text-xs font-bold text-slate-400">
                                    {t('vertProfile')} 
                                    {profile.isOptimized && <span className="text-purple-400 ml-2 font-bold">{t('aiOptimized')}</span>}
                                    {profile.isCustom && <span className="text-orange-400 ml-2 font-bold">{t('customRoute')}</span>}
                                </h4>
                                <div className="flex flex-col items-center bg-slate-800/80 p-1 rounded border border-slate-700 z-10">
                                    <span className="text-[8px] text-slate-400 uppercase mb-1 font-bold">{t('planAlt')}</span>
                                    <div className="flex items-center gap-1">
                                        <button className="p-1 hover:text-blue-400 bg-slate-900 rounded" onClick={()=>setDisplayAlt(a=>Math.max(minAlt, a-1000))}><Icon name="Minus" size={12}/></button>
                                        <span className="font-mono text-blue-400 text-sm font-bold w-14 text-center">{displayAlt}</span>
                                        <button className="p-1 hover:text-blue-400 bg-slate-900 rounded" onClick={()=>setDisplayAlt(a=>Math.min(maxAlt, a+1000))}><Icon name="Plus" size={12}/></button>
                                    </div>
                                </div>
                            </div>
                            <svg ref={svgRef} viewBox={`0 0 ${w} ${h}`} className="w-full h-full cursor-crosshair" onMouseMove={onMove} onMouseLeave={()=>setCursor(null)}>
                                {levels.map(l => (
                                    <g key={l}>
                                        <line x1={p} y1={y(l)} x2={w-p} y2={y(l)} stroke="#334155" strokeDasharray="2" />
                                        <text x={p-5} y={y(l)+3} className="text-[8px] fill-slate-500" textAnchor="end">{l}</text>
                                    </g>
                                ))}
                                {field}
                                <path d={pathD} fill="none" stroke={profile.isCustom ? "#f97316" : (profile.isOptimized ? "#a855f7" : "#10b981")} strokeWidth="3" />
                                <line x1={p} y1={h-p} x2={w-p} y2={h-p} stroke="#475569" />
                                <line x1={p} y1={p} x2={p} y2={h-p} stroke="#475569" />
                                {timeTicksArray.map((tick, i) => (
                                    <g key={i} transform={`translate(${x(tick.dist)}, ${h-p})`}>
                                        <line x1="0" y1="0" x2="0" y2="5" stroke="#64748b" />
                                        <text y="15" textAnchor="middle" className="text-[8px] fill-slate-400 font-mono">{tick.label}</text>
                                        <text y="24" textAnchor="middle" className="text-[7px] fill-slate-500 font-mono">({Math.round(tick.dist)}nm)</text>
                                    </g>
                                ))}
                                <g transform={`translate(${p}, ${h-10})`}>
                                    <text className="text-[10px] fill-white font-bold">{origin.icao}</text>
                                    <text y="12" className="text-[8px] fill-slate-400">{origin.elev_ft} ft</text>
                                </g>
                                {/* Render Waypoints on Axis */}
                                {profile.majorWaypoints && profile.majorWaypoints.map((wp, i) => {
                                    if(i===0 || i===profile.majorWaypoints.length-1) return null;
                                    const match = profile.waypoints.reduce((acc, p) => {
                                        const d = Geo.dist(p.lat, p.lon, wp.lat, wp.lon);
                                        return d < acc.d ? { d, p } : acc;
                                    }, { d: Infinity, p: null });
                                    
                                    if (match.p) {
                                        return (
                                            <g key={`wp-${i}`} transform={`translate(${x(match.p.totalDist)}, ${h-10})`} textAnchor="middle">
                                                <text className="text-[8px] fill-orange-400 font-bold">{wp.name}</text>
                                            </g>
                                        );
                                    }
                                    return null;
                                })}
                                <g transform={`translate(${w-p}, ${h-10})`} textAnchor="end">
                                    <text className="text-[10px] fill-white font-bold">{dest.icao}</text>
                                    <text y="12" className="text-[8px] fill-slate-400">{dest.elev_ft} ft</text>
                                </g>
                                {cursor && (
                                    <g>
                                        <line x1={p} y1={cursor.y} x2={w-p} y2={cursor.y} stroke="#f59e0b" strokeDasharray="2" />
                                        <line x1={cursor.x} y1={p} x2={cursor.x} y2={h-p} stroke="#f59e0b" strokeDasharray="2" />
                                        <text x={w-p} y={cursor.y-5} className="text-[10px] fill-white" textAnchor="end">{Math.round(cursor.alt)} ft</text>
                                        <text x={cursor.x+5} y={h-p-5} className="text-[10px] fill-white">{Math.round(cursor.d)} NM</text>
                                    </g>
                                )}
                                {cursorData && (
                                    <g transform={`translate(${w/2}, ${p/2})`}>
                                        <rect x="-60" y="-12" width="120" height="24" rx="4" fill="#1e293b" stroke="#475569" />
                                        <text y="4" textAnchor="middle" className="text-[10px] fill-white font-mono font-bold">
                                            {cursorData.time} | {cursorData.wind}
                                        </text>
                                    </g>
                                )}
                            </svg>
                        </div>
                    </div>
                );
            };

            const HelpModal = ({ onClose, t }) => (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="panel p-6 rounded-xl max-w-lg w-full mx-4 shadow-2xl border border-blue-500/30 max-h-[85vh] overflow-y-auto" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-6 border-b border-slate-700 pb-4">
                            <div className="flex items-center gap-3">
                                <div className="p-2 bg-blue-600/20 rounded-lg">
                                    <Icon name="HelpCircle" className="w-6 h-6 text-blue-400" />
                                </div>
                                <h2 className="text-xl font-bold text-white">{t('helpTitle')}</h2>
                            </div>
                            <button onClick={onClose} className="p-2 hover:bg-slate-800 rounded-full transition-colors">
                                <Icon name="X" className="w-5 h-5 text-slate-400" />
                            </button>
                        </div>
                        
                        <div className="space-y-6 text-sm text-slate-300">
                            <section>
                                <h3 className="text-white font-bold mb-2 flex items-center gap-2">
                                    <Icon name="Play" size={14} className="text-emerald-400" /> {t('helpStart')}
                                </h3>
                                <p className="leading-relaxed">
                                    {t('helpStartDesc')}
                                </p>
                            </section>

                            <section>
                                <h3 className="text-white font-bold mb-2 flex items-center gap-2">
                                    <Icon name="Move" size={14} className="text-orange-400" /> {t('helpEdit')}
                                </h3>
                                <p className="leading-relaxed">
                                    {t('helpEditDesc')}
                                </p>
                            </section>

                            <section>
                                <h3 className="text-white font-bold mb-2 flex items-center gap-2">
                                    <Icon name="BarChart3" size={14} className="text-blue-400" /> {t('helpVert')}
                                </h3>
                                <p className="leading-relaxed">
                                    {t('helpVertDesc')}
                                </p>
                            </section>

                            <section>
                                <h3 className="text-white font-bold mb-2 flex items-center gap-2">
                                    <Icon name="BrainCircuit" size={14} className="text-purple-400" /> {t('helpAi')}
                                </h3>
                                <p className="leading-relaxed">
                                    {t('helpAiDesc')}
                                </p>
                            </section>
                        </div>

                        <div className="mt-8 pt-4 border-t border-slate-700 text-center">
                            <button onClick={onClose} className="px-6 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg font-bold transition-colors w-full">
                                {t('gotIt')}
                            </button>
                        </div>
                    </div>
                </div>
            );

            const KeyModal = ({ onClose, error, t }) => (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="panel p-6 rounded-xl max-w-md w-full mx-4 shadow-2xl border border-blue-500/50" onClick={e => e.stopPropagation()}>
                        <div className="flex flex-col items-center text-center">
                            <div className="w-16 h-16 bg-blue-900/50 rounded-full flex items-center justify-center mb-4 border border-blue-500">
                                <Icon name="Key" className="w-8 h-8 text-blue-400" />
                            </div>
                            <h2 className="text-xl font-bold text-white mb-2">
                                {error ? "Invalid API Key" : "Gemini API Key Required"}
                            </h2>
                            <p className="text-slate-300 text-sm mb-6 leading-relaxed">
                                {error ? "The API Key provided is not valid or has expired. Please update it." : "To use the AI optimization and advanced aircraft performance features, you need a valid Google Gemini API Key."}
                            </p>
                            
                            <a href="https://aistudio.google.com/app/apikey" target="_blank" className="w-full py-3 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-500 hover:to-indigo-500 rounded-lg font-bold text-white shadow-lg mb-3 flex items-center justify-center gap-2 transition-all transform hover:scale-[1.02]">
                                <Icon name="ExternalLink" size={16}/> {t('getKey')}
                            </a>
                            
                            <button onClick={onClose} className="text-slate-400 hover:text-white text-xs mt-2 underline">
                                {t('close')}
                            </button>
                        </div>
                    </div>
                </div>
            );

            function App() {
                // Returns current UTC time formatted for datetime-local input
                const getUTCISOString = () => new Date().toISOString().slice(0, 16);

                const [apiKey, setApiKey] = useState(localStorage.getItem('aero_key_final') || '');
                const [lang, setLang] = useState('en');
                const [params, setParams] = useState(() => {
                    const s = localStorage.getItem('aero_params_final');
                    const defaults = { origin: 'EGLL', dest: 'LFPG', aircraft: 'C172', minAlt: 2000, maxAlt: 10000, fuelUnit: 'gal', climbPower: 80, cruisePower: 70, manualSpd: 0, manualDir: 0 };
                    const loaded = JSON.parse(s||'{}');
                    return { ...defaults, ...loaded, dep: getUTCISOString() };
                });
                
                const [displayAlt, setDisplayAlt] = useState(parseInt(params.minAlt) || 2000);
                const [isOptimized, setIsOptimized] = useState(false);
                const [customRoute, setCustomRoute] = useState([]); 

                const [optimizationState, setOptimizationState] = useState(null); 
                const [status, setStatus] = useState('idle');
                const [progress, setProgress] = useState(''); 
                const [data, setData] = useState(null); 
                const [profile, setProfile] = useState(null);
                const [warnings, setWarnings] = useState([]);
                const [error, setError] = useState(null);
                const [mapType, setMapType] = useState('satellite');
                const [showKeyModal, setShowKeyModal] = useState(false);
                const [showHelpModal, setShowHelpModal] = useState(false);
                const [keyError, setKeyError] = useState(false);
                
                const [isMobile, setIsMobile] = useState(false);

                const t = (key) => TRANSLATIONS[lang][key] || TRANSLATIONS['en'][key];

                useEffect(() => localStorage.setItem('aero_key_final', apiKey), [apiKey]);
                useEffect(() => localStorage.setItem('aero_params_final', JSON.stringify(params)), [params]);
                
                useEffect(() => {
                    setDisplayAlt(parseInt(params.minAlt) || 2000);
                }, [params.minAlt]);

                useEffect(() => {
                    if (!isOptimized) {
                        setOptimizationState(null);
                        if (data) setStatus('calc_needed');
                    }
                }, [isOptimized]);
                
                useEffect(() => {
                    const checkMobile = () => setIsMobile(window.innerWidth < 1024);
                    checkMobile();
                    window.addEventListener('resize', checkMobile);
                    return () => window.removeEventListener('resize', checkMobile);
                }, []);

                const onAddWaypoint = (lat, lon, index) => {
                    const newPt = { lat, lon };
                    const updated = [...customRoute];
                    updated.splice(index - 1, 0, newPt); 
                    setCustomRoute(updated);
                    setIsOptimized(false);
                    setStatus('calc_needed');
                };

                const resetRoute = () => {
                    setCustomRoute([]);
                    setIsOptimized(false);
                    setStatus('calc_needed');
                };

                const run = async () => {
                    setStatus('fetching'); setProgress('Fetching Airport & Perf...'); setWarnings([]); setError(null); setCustomRoute([]);
                    try {
                        let perf;
                        try {
                            const rawPerf = await Services.fetchPerf(params.aircraft, apiKey);
                            const parse = (val) => parseFloat(String(val).replace(/[^0-9.]/g, '')) || 0;
                            perf = { 
                                climb_rate: Math.round(parse(rawPerf.climb_rate) * (params.climbPower / 100)),
                                climb_spd: parse(rawPerf.climb_spd),
                                cruise_spd: Math.round(parse(rawPerf.cruise_spd) * (params.cruisePower / 100)),
                                desc_rate: parse(rawPerf.desc_rate),
                                desc_spd: parse(rawPerf.desc_spd),
                                burn: parse(rawPerf.burn)
                            };
                        } catch (e) {
                            if (e.message === "INVALID_API_KEY" || e.message === "NO_KEY") {
                                // Fallback: Clear API key to revert to Dropdown, use default aircraft stats
                                setApiKey(''); 
                                localStorage.removeItem('aero_key_final');
                                
                                let acKey = params.aircraft;
                                // If the custom text entered isn't a known key, revert to C172
                                if(!CONSTANTS.AIRCRAFT_PERF[acKey]) {
                                    acKey = 'C172';
                                }
                                
                                setParams(p => ({...p, aircraft: acKey}));
                                const defaultPerf = CONSTANTS.AIRCRAFT_PERF[acKey];
                                
                                // Manually set perf from default
                                perf = {
                                    climb_rate: Math.round(defaultPerf.climb_rate * (params.climbPower / 100)),
                                    climb_spd: defaultPerf.climb_spd,
                                    cruise_spd: Math.round(defaultPerf.cruise_spd * (params.cruisePower / 100)),
                                    desc_rate: defaultPerf.desc_rate,
                                    desc_spd: defaultPerf.desc_spd,
                                    burn: defaultPerf.burn
                                };
                                setWarnings(p => [...p, "API Key Invalid - Reverted to Standard Aircraft Database"]);
                            } else {
                                throw e;
                            }
                        }

                        const [o, d] = await Promise.all([
                            Services.fetchAirport(params.origin), 
                            Services.fetchAirport(params.dest)
                        ]);

                        const dist = Geo.dist(o.lat, o.lon, d.lat, d.lon);
                        const steps = Math.ceil(dist / CONSTANTS.GRID_STEP);
                        const brg = Geo.bearing(o.lat, o.lon, d.lat, d.lon);
                        const grid = [];
                        let gCounter = 0; 
                        
                        for(let i=0; i<=steps; i++) {
                            const distAlong = (i/steps)*dist;
                            const c = Geo.offset(o.lat, o.lon, distAlong, brg);
                            grid.push({ ...c, idx: i, distAlong, type: 'C', gIdx: gCounter++ }); 
                            grid.push({ ...Geo.offset(c.lat, c.lon, 50, brg-90), idx: i, distAlong, type: 'L50', gIdx: gCounter++ }); 
                            grid.push({ ...Geo.offset(c.lat, c.lon, 100, brg-90), idx: i, distAlong, type: 'L100', gIdx: gCounter++ }); 
                            grid.push({ ...Geo.offset(c.lat, c.lon, 50, brg+90), idx: i, distAlong, type: 'R50', gIdx: gCounter++ }); 
                            grid.push({ ...Geo.offset(c.lat, c.lon, 100, brg+90), idx: i, distAlong, type: 'R100', gIdx: gCounter++ }); 
                        }

                        setProgress('Fetching Weather...');
                        const manual = (params.manualSpd > 0) ? { speed: params.manualSpd, dir: params.manualDir } : null;
                        
                        // Treat the input string as UTC time by appending 'Z'
                        const fetchDate = new Date(params.dep + 'Z');
                        
                        const wx = await Services.fetchWeather(grid, params.minAlt, params.maxAlt, fetchDate, (curr, total) => {
                            setProgress(`Fetching Weather (${curr}/${total})...`);
                        }, manual);
                        
                        if (!wx.some(w => w.hourly) && !manual) {
                            // If fallback was triggered (wx exists but no hourly, or just fallback flag logic)
                            // Actually fetchWeather returns full 'wx' objects even on fallback
                            // We can detect fallback if every hour has identical wind
                            setWarnings(p => [...p, "WEATHER API FAILED - USING STANDARD ATMOSPHERE MODEL"]);
                        }

                        setData({ grid, wx, perf, origin: o, dest: d });
                        setStatus('calc_needed');
                    } catch(e) { 
                        setError(e.message); 
                        setStatus('idle'); 
                    }
                };

                const toggleOptimization = async () => {
                    if (isOptimized) {
                        setIsOptimized(false);
                        return;
                    }
                    if (customRoute.length > 0) {
                        if(!confirm("Optimizing will clear your custom waypoints. Continue?")) return;
                        setCustomRoute([]);
                    }

                    if (!apiKey || apiKey.trim() === "") {
                        setKeyError(false);
                        setShowKeyModal(true);
                        return;
                    }

                    setIsOptimized(true);
                    setStatus('optimizing'); 
                    
                    try {
                        const { grid, wx, perf, origin, dest } = data;
                        const testLevels = CONSTANTS.LEVELS.filter(l => l >= params.minAlt && l <= params.maxAlt);
                        const testStrats = ['C', 'L100', 'R100'];
                        
                        // Treat input as UTC
                        const depMs = new Date(params.dep + 'Z').getTime();

                        const options = [];
                        testLevels.forEach(alt => {
                            testStrats.forEach(strat => {
                                const sim = Physics.calculateProfile(grid, wx, perf, origin, dest, strat, alt, depMs);
                                options.push({
                                    alt: alt,
                                    strategy: strat,
                                    time: sim.time, // ms
                                    timeFormatted: Geo.formatDuration(sim.time / 3600000),
                                    fuel: sim.fuel
                                });
                            });
                        });
                        options.sort((a, b) => a.time - b.time);
                        const topCandidates = options.slice(0, 3);
                        
                        const aiRes = await Services.optimizeRoute(topCandidates, apiKey, lang);
                        
                        let strat = aiRes.strategy || 'C'; 
                        let alt = aiRes.alt || topCandidates[0].alt;
                        const reason = aiRes.reasoning || "AI selected best calculated route.";
                        
                        if(strat === 'L') strat = 'L100';
                        if(strat === 'R') strat = 'R100';

                        setOptimizationState({ strategy: strat, alt: alt, reasoning: reason });
                        setDisplayAlt(alt);
                        setStatus('calc_needed');

                    } catch (e) {
                        setIsOptimized(false);
                        if (e.message === "INVALID_KEY") {
                            setKeyError(true);
                            setShowKeyModal(true);
                        } else {
                            console.error(e);
                            setError(t('aiError') + ": " + e.message);
                        }
                        setStatus('calc_needed');
                    }
                };

                useEffect(() => {
                    if(status !== 'calc_needed' && status !== 'success') return;
                    if(!data) return;
                    const { grid, wx, perf, origin, dest } = data;
                    
                    // Treat input as UTC
                    const depMs = new Date(params.dep + 'Z').getTime();

                    const strat = (isOptimized && optimizationState) ? optimizationState.strategy : 'C';
                    const level = (isOptimized && optimizationState) ? optimizationState.alt : displayAlt;

                    const result = Physics.calculateProfile(grid, wx, perf, origin, dest, strat, level, depMs, customRoute);

                    setProfile({
                        waypoints: result.waypoints,
                        majorWaypoints: result.majorWaypoints,
                        chartGeometry: result.chartGeometry,
                        isOptimized,
                        isCustom: customRoute.length > 0,
                        strategy: strat,
                        reasoning: optimizationState?.reasoning,
                        stats: {
                            distance: result.dist,
                            time: Geo.formatDuration(result.time/3600000),
                            fuel: result.fuel.toFixed(1),
                            eta: Geo.formatTime(new Date(result.arrival)),
                            arrival: result.arrival,
                            departure: depMs,
                            climb_spd: perf.climb_spd,
                            cruise_spd: perf.cruise_spd
                        }
                    });
                    setStatus('success');
                }, [status, data, displayAlt, isOptimized, optimizationState, customRoute]);

                const getDisplayFuel = () => profile ? (params.fuelUnit === 'l' ? (parseFloat(profile.stats.fuel) * 3.78541).toFixed(1) : profile.stats.fuel) : "0.0";

                return (
                    <div className="min-h-screen pt-4 lg:pt-12 p-2 lg:p-6 max-w-7xl mx-auto flex flex-col gap-4 lg:gap-6 relative">
                        <div className="fixed top-0 left-0 w-full bg-red-600 text-white text-center text-[10px] font-bold py-1 z-[9999] shadow-lg tracking-widest">{t('eduWarning')}</div>
                        {warnings.map((w, i) => <div key={i} className="fixed top-8 left-0 w-full bg-orange-600/90 text-white text-center text-[10px] font-bold py-1 z-[9998]">{w}</div>)}
                        
                        {status === 'optimizing' && (
                            <div className="wait-overlay">
                                <div className="spinner mb-6"></div>
                                <h2 className="text-2xl font-bold text-white mb-2">{t('aiOpt')}</h2>
                                <p className="text-slate-400 text-sm">{t('aiThinking')}</p>
                            </div>
                        )}

                        {showHelpModal && <HelpModal onClose={() => setShowHelpModal(false)} t={t} />}
                        {showKeyModal && <KeyModal onClose={() => setShowKeyModal(false)} error={keyError} t={t} />}

                        {error && <div className="fixed inset-0 z-[10000] flex items-center justify-center bg-black/80 backdrop-blur-sm"><div className="bg-slate-900 border border-red-500 rounded-xl p-8 max-w-md w-full shadow-2xl text-center"><Icon name="AlertTriangle" className="w-16 h-16 text-red-500 mx-auto mb-4"/><h2 className="text-xl font-bold text-white mb-2">{t('calc') + " Aborted"}</h2><p className="text-slate-300 text-sm mb-6">{error}</p><button onClick={() => setError(null)} className="px-6 py-2 bg-red-600 hover:bg-red-700 text-white rounded font-bold">{t('close')}</button></div></div>}

                        <div className="panel p-4 rounded-xl flex flex-col lg:flex-row justify-between items-center mt-2 gap-3 lg:gap-0">
                            <div className="flex items-center gap-3 w-full lg:w-auto justify-center lg:justify-start">
                                <img src="https://xaxero.com/images/XaxeroLogoSansSloganCopy.png" alt="Xaxero" className="h-8 lg:h-10"/>
                                <div><h1 className="text-lg lg:text-xl font-bold">{t('title')}</h1></div>
                                <span className="text-[10px] bg-blue-900 px-2 py-0.5 rounded text-blue-200 border border-blue-700 whitespace-nowrap">ALL TIMES UTC</span>
                                <button onClick={() => setShowHelpModal(true)} className="ml-2 w-8 h-8 rounded-full bg-blue-600 hover:bg-blue-500 text-white flex items-center justify-center transition-all shadow-lg shadow-blue-900/50 font-bold text-lg" title={t('helpTitle')}>
                                    ?
                                </button>
                                <select value={lang} onChange={(e) => setLang(e.target.value)} className="bg-slate-700 text-white text-xs p-1 rounded border border-slate-600 focus:outline-none focus:border-blue-500">
                                    <option value="en">EN</option>
                                    <option value="fr">FR</option>
                                    <option value="es">ES</option>
                                    <option value="de">DE</option>
                                </select>
                            </div>
                            <div className="flex flex-row items-center gap-2 w-full lg:w-auto justify-center lg:justify-end">
                                <input type="password" value={apiKey} onChange={e=>setApiKey(e.target.value)} placeholder={t('apiKey')} className="input-field p-2 rounded w-full lg:w-40 text-xs text-center border-slate-600 focus:border-blue-500" />
                                {(!apiKey || apiKey.trim() === "") && (
                                    <a href="https://aistudio.google.com/app/apikey" target="_blank" className="text-[10px] text-blue-400 hover:text-blue-300 underline flex items-center gap-1 whitespace-nowrap">
                                        <Icon name="Key" size={10} /> {t('getKey')}
                                    </a>
                                )}
                            </div>
                        </div>

                        <div className="grid grid-cols-1 lg:grid-cols-12 gap-4 lg:gap-6 flex-1">
                            {/* LEFT COLUMN: Controls */}
                            <div className="lg:col-span-4 flex flex-col gap-4 order-2 lg:order-1">
                                <div className="panel p-5 rounded-xl space-y-4">
                                    <div className="grid grid-cols-2 gap-3">
                                        <div><label className="text-[10px] text-slate-400 block mb-1">{t('origin')}</label><input className="input-field w-full p-2 rounded text-center" value={params.origin} onChange={e=>setParams({...params, origin: e.target.value.toUpperCase()})} /></div>
                                        <div><label className="text-[10px] text-slate-400 block mb-1">{t('dest')}</label><input className="input-field w-full p-2 rounded text-center" value={params.dest} onChange={e=>setParams({...params, dest: e.target.value.toUpperCase()})} /></div>
                                    </div>
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="text-[10px] text-slate-400 block mb-1">{t('aircraft')}</label>
                                            {apiKey ? (
                                                <>
                                                    <input 
                                                        list="aircraft-presets"
                                                        className="input-field w-full p-2 rounded text-center" 
                                                        value={params.aircraft} 
                                                        onChange={e=>setParams({...params, aircraft: e.target.value.toUpperCase()})} 
                                                        placeholder="Type or Select..."
                                                    />
                                                    <datalist id="aircraft-presets">
                                                        {Object.entries(CONSTANTS.AIRCRAFT_PERF).map(([k, v]) => (
                                                            <option key={k} value={k}>{v.name}</option>
                                                        ))}
                                                    </datalist>
                                                </>
                                            ) : (
                                                <select className="input-field w-full p-2 rounded text-center text-xs" value={params.aircraft} onChange={e=>setParams({...params, aircraft: e.target.value})}>
                                                    {Object.entries(CONSTANTS.AIRCRAFT_PERF).map(([k, v]) => (
                                                        <option key={k} value={k}>{v.name}</option>
                                                    ))}
                                                </select>
                                            )}
                                        </div>
                                        <div><label className="text-[10px] text-slate-400 block mb-1">{t('dep')}</label><input type="datetime-local" className="input-field w-full p-2 rounded text-[10px]" value={params.dep} onChange={e=>setParams({...params, dep: e.target.value})} /></div>
                                    </div>
                                    <div className="grid grid-cols-2 gap-3 p-2 bg-slate-800/50 rounded border border-slate-700">
                                        <div><label className="text-[10px] text-slate-400 block mb-1">{t('minAlt')}</label><input type="number" step="1000" className="input-field w-full p-1 rounded text-right" value={params.minAlt} onChange={e=>setParams({...params, minAlt: parseInt(e.target.value) || 0})} /></div>
                                        <div><label className="text-[10px] text-slate-400 block mb-1">{t('maxAlt')}</label><input type="number" step="1000" className="input-field w-full p-1 rounded text-right" value={params.maxAlt} onChange={e=>setParams({...params, maxAlt: parseInt(e.target.value) || 0})} /></div>
                                    </div>
                                    <div className="grid grid-cols-2 gap-3 p-2 bg-slate-800/50 rounded border border-slate-700">
                                        <div><label className="text-[10px] text-slate-400 block mb-1">{t('climbPwr')}</label><input type="number" min="50" max="100" className="input-field w-full p-1 rounded text-right" value={params.climbPower} onChange={e=>setParams({...params, climbPower: parseInt(e.target.value)||80})} /></div>
                                        <div><label className="text-[10px] text-slate-400 block mb-1">{t('cruisePwr')}</label><input type="number" min="50" max="100" className="input-field w-full p-1 rounded text-right" value={params.cruisePower} onChange={e=>setParams({...params, cruisePower: parseInt(e.target.value)||70})} /></div>
                                    </div>
                                    <div className="flex justify-between items-center bg-slate-800/30 p-2 rounded">
                                        <span className="text-[10px] text-slate-400 font-bold">{t('fuelUnits')}</span>
                                        <div className="flex bg-slate-900 rounded border border-slate-700 p-0.5">
                                            <button onClick={()=>setParams({...params, fuelUnit: 'gal'})} className={`px-3 py-1 text-[10px] font-bold rounded ${params.fuelUnit==='gal'?'bg-blue-600 text-white':'text-slate-400'}`}>USG</button>
                                            <button onClick={()=>setParams({...params, fuelUnit: 'l'})} className={`px-3 py-1 text-[10px] font-bold rounded ${params.fuelUnit==='l'?'bg-blue-600 text-white':'text-slate-400'}`}>LIT</button>
                                        </div>
                                    </div>
                                    <button onClick={run} disabled={status === 'fetching' || status === 'optimizing'} className="w-full py-3 bg-blue-600 hover:bg-blue-500 rounded font-bold text-sm shadow-lg transition-colors flex justify-center items-center gap-2">
                                        {status === 'fetching' ? <><Icon name="Loader2" className="animate-spin"/> {progress || t('calcing')}</> : <><Icon name="Play"/> {t('calc')}</>}
                                    </button>
                                    <button onClick={toggleOptimization} disabled={!data || status === 'optimizing'} className={`w-full py-4 rounded-xl font-bold text-sm shadow-xl transition-all flex justify-center items-center gap-2 border border-slate-600 ${isOptimized ? 'ai-btn-active text-white scale-[0.98]' : 'bg-slate-700 hover:bg-slate-600 text-slate-300'}`}>
                                        {status === 'optimizing' ? <Icon name="Loader2" className="animate-spin"/> : <Icon name={isOptimized ? "Sparkles" : "BrainCircuit"} />}
                                        {status === 'optimizing' ? t('aiThinking') : (isOptimized ? t('aiOptimized') : t('aiOpt'))}
                                    </button>
                                    
                                    {customRoute.length > 0 && (
                                        <button onClick={resetRoute} className="w-full py-2 bg-orange-700 hover:bg-orange-600 text-white rounded font-bold text-xs shadow-lg transition-colors flex justify-center items-center gap-2">
                                            <Icon name="RefreshCw" size={12}/> {t('reset')}
                                        </button>
                                    )}
                                </div>
                                {profile && (
                                    <div className="panel p-4 rounded-xl space-y-4 fade-in">
                                        {profile.isOptimized && profile.reasoning && (
                                            <div className="bg-purple-900/50 border border-purple-500/30 p-2 rounded text-[10px] text-purple-200 text-center">
                                                <span className="font-bold block mb-1">{t('aiStrategy')}: {profile.strategy === 'L' || profile.strategy === 'L100' ? t('deviateLeft') : profile.strategy === 'R' || profile.strategy === 'R100' ? t('deviateRight') : t('stayCenter')}</span>
                                                {profile.reasoning}
                                            </div>
                                        )}
                                        {profile.isCustom && (
                                            <div className="bg-orange-900/50 border border-orange-500/30 p-2 rounded text-[10px] text-orange-200 text-center font-bold">
                                                {t('customRoute')} ({customRoute.length} {t('waypoints')})
                                            </div>
                                        )}
                                        <div className="grid grid-cols-2 gap-4 text-center">
                                            <div><div className="text-[10px] text-slate-400">{t('ete')}</div><div className="text-xl font-bold">{profile.stats.time}</div></div>
                                            <div><div className="text-[10px] text-slate-400">{t('fuel')} ({params.fuelUnit.toUpperCase()})</div><div className="text-xl font-bold text-emerald-400">{getDisplayFuel()}</div></div>
                                            <div><div className="text-[10px] text-slate-400">{t('dist')}</div><div className="text-xl font-bold text-blue-400">{profile.stats.distance}nm</div></div>
                                            <div><div className="text-[10px] text-slate-400">{t('eta')}</div><div className="text-xl font-bold">{profile.stats.eta}</div></div>
                                        </div>
                                        
                                        {/* Added Date Confirmation */}
                                        <div className="text-center text-[10px] text-slate-500 border-t border-slate-700 pt-2">
                                            Weather Date: {params.dep.split('T')[0]} via Open-Meteo
                                        </div>

                                        <div className="border-t border-slate-700 pt-3 mt-1">
                                            <div className="flex justify-between text-xs text-slate-300">
                                                <span>{t('climbTas')}: <span className="text-blue-400 font-mono">{profile.stats.climb_spd}kt</span></span>
                                                <span>{t('cruiseTas')}: <span className="text-blue-400 font-mono">{profile.stats.cruise_spd}kt</span></span>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                            <div className="lg:col-span-8 flex flex-col gap-4 order-1 lg:order-2">
                                <MapView 
                                    data={data} 
                                    profile={profile} 
                                    displayAlt={displayAlt} 
                                    setDisplayAlt={setDisplayAlt} 
                                    minAlt={params.minAlt} 
                                    maxAlt={params.maxAlt} 
                                    mapType={mapType} 
                                    setMapType={setMapType} 
                                    onAddWaypoint={onAddWaypoint} 
                                    className="h-[45vh] lg:h-[500px]"
                                    t={t}
                                />
                                <ProfileView profile={profile} displayAlt={displayAlt} setDisplayAlt={setDisplayAlt} minAlt={params.minAlt} maxAlt={params.maxAlt} origin={data?.origin} dest={data?.dest} t={t} />
                            </div>
                        </div>
                    </div>
                );
            };

            const root = ReactDOM.createRoot(document.getElementById('root'));
            try {
                root.render(<App />);
            } catch (e) {
                console.error("React Render Error:", e);
                document.body.innerHTML = `<div style="color:red; padding:20px;"><h1>App Crashed</h1><pre>${e.message}</pre></div>`;
            }
        });
    </script>
</body>
</html>